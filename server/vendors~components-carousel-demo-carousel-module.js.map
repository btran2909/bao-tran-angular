{"version":3,"sources":["bao-tran-angular/carousel/carousel.config.ts","bao-tran-angular/carousel/utils.ts","bao-tran-angular/carousel/carousel.component.ts","bao-tran-angular/carousel/slide.component.ts","bao-tran-angular/carousel/carousel.module.ts"],"names":[],"mappings":"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","file":"vendors~components-carousel-demo-carousel-module.js","sourcesContent":["import { Injectable } from '@angular/core';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class CarouselConfig {\r\n  /* Default interval of auto changing of slides */\r\n  interval = 5000;\r\n\r\n  /* Is loop of auto changing of slides can be paused */\r\n  noPause = false;\r\n\r\n  /* Is slides can wrap from the last to the first slide */\r\n  noWrap = false;\r\n\r\n  /* Show carousel-indicators */\r\n  showIndicators = true;\r\n\r\n  /* Slides can be paused on focus */\r\n  pauseOnFocus = false;\r\n\r\n  /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\r\n  indicatorsByChunk = false;\r\n\r\n  /* If value more then 1 — carousel works in multilist mode */\r\n  itemsPerSlide = 1;\r\n\r\n  /* If `true` — carousel shifts by one element. By default carousel shifts by number\r\n    of visible elements (itemsPerSlide field) */\r\n  singleSlideOffset = false;\r\n}\r\n","/**\r\n * Returns the index of the last element in the array where predicate is true, and -1\r\n * otherwise.\r\n * @param array The source array to search in\r\n * @param predicate find calls predicate once for each element of the array, in descending\r\n * order, until it finds one where predicate returns true. If such an element is found,\r\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\r\n */\r\nexport function findLastIndex<T>(array: T[], predicate: (value: T, index: number, obj: T[]) => boolean): number {\r\n  let l = array.length;\r\n\r\n  while (l--) {\r\n    if (predicate(array[l], l, array)) {\r\n      return l;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nexport function chunkByNumber<T>(array: T[], size: number): T[][] {\r\n  const out = [];\r\n  const n = Math.ceil((array.length) / size);\r\n  let i = 0;\r\n\r\n  while (i < n) {\r\n    const chunk = array.splice(\r\n      0,\r\n      (i === n - 1) && size < array.length ? array.length : size\r\n    );\r\n\r\n    out.push(chunk);\r\n    i++;\r\n  }\r\n\r\n  return out;\r\n}\r\n","// tslint:disable:max-file-line-count\n/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\n/****\n * Problems:\n * 1) if we set an active slide via model changes, .active class remains on a\n * current slide.\n * 2) if we have only one slide, we shouldn't show prev/next nav buttons\n * 3) if first or last slide is active and noWrap is true, there should be\n * \"disabled\" class on the nav buttons.\n * 4) default interval should be equal 5000\n */\n\nimport {\n  Component, EventEmitter, Input, NgZone, OnDestroy, Output, AfterViewInit\n} from '@angular/core';\n\nimport { isBs3, LinkedList } from 'bao-tran-angular/utils';\nimport { SlideComponent } from './slide.component';\nimport { CarouselConfig } from './carousel.config';\nimport { findLastIndex, chunkByNumber } from './utils';\nimport { SlideWithIndex, IndexedSlideList } from './models';\n\nexport enum Direction {\n  UNKNOWN,\n  NEXT,\n  PREV\n}\n\n/**\n * Base element to create carousel\n */\n@Component({\n  selector: 'carousel',\n  templateUrl: './carousel.component.html'\n})\nexport class CarouselComponent implements AfterViewInit, OnDestroy {\n  /* If `true` — carousel will not cycle continuously and will have hard stops (prevent looping) */\n  @Input() noWrap: boolean;\n  /*  If `true` — will disable pausing on carousel mouse hover */\n  @Input() noPause: boolean;\n  /*  If `true` — carousel-indicators are visible  */\n  @Input() showIndicators: boolean;\n  /*  If `true` - autoplay will be stopped on focus */\n  @Input() pauseOnFocus: boolean;\n  /* If `true` - carousel indicators indicate slides chunks\n     works ONLY if singleSlideOffset = FALSE */\n  @Input() indicatorsByChunk = false;\n  /* If value more then 1 — carousel works in multilist mode */\n  @Input() itemsPerSlide = 1;\n  /* If `true` — carousel shifts by one element. By default carousel shifts by number\n     of visible elements (itemsPerSlide field) */\n  @Input() singleSlideOffset = false;\n  /** Turn on/off animation. Animation doesn't work for multilist carousel */\n  @Input() isAnimated = false;\n\n  /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n  @Output()\n  activeSlideChange: EventEmitter<number> = new EventEmitter<number>(false);\n\n  /** Will be emitted when active slides has been changed in multilist mode */\n  @Output()\n  slideRangeChange: EventEmitter<number[]> = new EventEmitter<number[]>();\n\n  /** Index of currently displayed slide(started for 0) */\n  @Input()\n  set activeSlide(index: number) {\n    if (this.multilist) {\n      return;\n    }\n    if (this._slides.length && index !== this._currentActiveSlide) {\n      this._select(index);\n    }\n  }\n\n  get activeSlide(): number {\n    return this._currentActiveSlide;\n  }\n\n  /* Index to start display slides from it */\n  @Input()\n  startFromIndex = 0;\n\n  /**\n   * Delay of item cycling in milliseconds. If false, carousel won't cycle\n   * automatically.\n   */\n  @Input()\n  get interval(): number {\n    return this._interval;\n  }\n\n  set interval(value: number) {\n    this._interval = value;\n    this.restartTimer();\n  }\n\n  get slides(): SlideComponent[] {\n    return this._slides.toArray();\n  }\n\n  // tslint:disable-next-line:no-any\n  protected currentInterval: any;\n  protected _currentActiveSlide: number;\n  protected _interval: number;\n  protected _slides: LinkedList<SlideComponent> = new LinkedList<SlideComponent>();\n  protected _chunkedSlides: SlideWithIndex[][];\n  protected _slidesWithIndexes: SlideWithIndex[];\n  protected _currentVisibleSlidesIndex = 0;\n  protected isPlaying: boolean;\n  protected destroyed = false;\n\n  get isBs4(): boolean {\n    return !isBs3();\n  }\n\n  constructor(config: CarouselConfig, private ngZone: NgZone) {\n    Object.assign(this, config);\n  }\n\n  ngAfterViewInit(): void {\n    setTimeout(() => {\n      if (this.singleSlideOffset) {\n        this.indicatorsByChunk = false;\n      }\n      if (this.multilist) {\n        this._chunkedSlides = chunkByNumber(\n          this.mapSlidesAndIndexes(),\n          this.itemsPerSlide\n        );\n        this.selectInitialSlides();\n      }\n    }, 0);\n  }\n\n  ngOnDestroy(): void {\n    this.destroyed = true;\n  }\n\n  /**\n   * Adds new slide. If this slide is first in collection - set it as active\n   * and starts auto changing\n   * @param slide\n   */\n  addSlide(slide: SlideComponent): void {\n    this._slides.add(slide);\n\n    if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n      slide.active = true;\n    }\n\n    if (!this.multilist && this.isAnimated) {\n      slide.isAnimated = true;\n    }\n\n    if (!this.multilist && this._slides.length === 1) {\n      this._currentActiveSlide = undefined;\n      this.activeSlide = 0;\n      this.play();\n    }\n\n    if (this.multilist && this._slides.length > this.itemsPerSlide) {\n      this.play();\n    }\n  }\n\n  /**\n   * Removes specified slide. If this slide is active - will roll to another\n   * slide\n   * @param slide\n   */\n  removeSlide(slide: SlideComponent): void {\n    const remIndex = this._slides.indexOf(slide);\n\n    if (this._currentActiveSlide === remIndex) {\n      // removing of active slide\n      let nextSlideIndex: number = void 0;\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is\n        // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n        // middle of collection, index of next slide is same to removed\n        nextSlideIndex = !this.isLast(remIndex)\n          ? remIndex\n          : this.noWrap ? remIndex - 1 : 0;\n      }\n      this._slides.remove(remIndex);\n\n      // prevents exception with changing some value after checking\n      setTimeout(() => {\n        this._select(nextSlideIndex);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n      const currentSlideIndex = this.getCurrentSlideIndex();\n      setTimeout(() => {\n        // after removing, need to actualize index of current active slide\n        this._currentActiveSlide = currentSlideIndex;\n        this.activeSlideChange.emit(this._currentActiveSlide);\n      }, 0);\n    }\n  }\n\n  nextSlideFromInterval(force = false): void {\n    this.move(Direction.NEXT, force);\n  }\n\n  /**\n   * Rolling to next slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  nextSlide(force = false): void {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    this.move(Direction.NEXT, force);\n  }\n\n  /**\n   * Rolling to previous slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  previousSlide(force = false): void {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    this.move(Direction.PREV, force);\n  }\n\n  getFirstVisibleIndex(): number {\n    return this.slides.findIndex(this.getActive);\n  }\n\n  getLastVisibleIndex(): number {\n    return findLastIndex(this.slides, this.getActive);\n  }\n\n  getActive = (slide: SlideComponent) => slide.active;\n\n  move(direction: Direction, force = false): void {\n    const firstVisibleIndex = this.getFirstVisibleIndex();\n    const lastVisibleIndex = this.getLastVisibleIndex();\n\n    if (this.noWrap) {\n      if (\n        direction === Direction.NEXT &&\n        this.isLast(lastVisibleIndex) ||\n        direction === Direction.PREV &&\n        firstVisibleIndex === 0\n      ) {\n        return;\n      }\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.findNextSlideIndex(direction, force);\n    } else {\n      this.moveMultilist(direction);\n    }\n  }\n\n  /**\n   * Swith slides by enter, space and arrows keys\n   * @internal\n   */\n  keydownPress(event: KeyboardEvent) {\n    // tslint:disable-next-line:deprecation\n    if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n      this.nextSlide();\n      event.preventDefault();\n\n      return;\n    }\n\n    // tslint:disable-next-line:deprecation\n    if (event.keyCode === 37 || event.key === 'LeftArrow') {\n      this.previousSlide();\n\n      return;\n    }\n\n    // tslint:disable-next-line:deprecation\n    if (event.keyCode === 39 || event.key === 'RightArrow') {\n      this.nextSlide();\n\n      return;\n    }\n  }\n\n  /**\n   * Play on mouse leave\n   * @internal\n   */\n  onMouseLeave(): void {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n\n  /**\n   * Play on mouse up\n   * @internal\n   */\n  onMouseUp(): void {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n\n  /**\n   * When slides on focus autoplay is stopped(optional)\n   * @internal\n   */\n  pauseFocusIn(): void {\n    if (this.pauseOnFocus) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n\n  /**\n   * When slides out of focus autoplay is started\n   * @internal\n   */\n  pauseFocusOut(): void {\n    this.play();\n  }\n\n  /**\n   * Rolling to specified slide\n   * @param index: {number} index of slide, which must be shown\n   */\n  selectSlide(index: number): void {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n    } else {\n      this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n    }\n  }\n\n  /**\n   * Starts a auto changing of slides\n   */\n  play(): void {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  }\n\n  /**\n   * Stops a auto changing of slides\n   */\n  pause(): void {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n\n  /**\n   * Finds and returns index of currently displayed slide\n   */\n  getCurrentSlideIndex(): number {\n    return this._slides.findIndex(this.getActive);\n  }\n\n  /**\n   * Defines, whether the specified index is last in collection\n   * @param index\n   */\n  isLast(index: number): boolean {\n    return index + 1 >= this._slides.length;\n  }\n\n  /**\n   * Defines, whether the specified index is first in collection\n   * @param index\n   */\n  isFirst(index: number): boolean {\n    return index === 0;\n  }\n\n  indicatorsSlides(): SlideComponent[] {\n    return this.slides.filter(\n      (slide: SlideComponent, index: number) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0\n    );\n  }\n\n  private selectInitialSlides(): void {\n    const startIndex = this.startFromIndex <= this._slides.length\n      ? this.startFromIndex\n      : 0;\n\n    this.hideSlides();\n\n    if (this.singleSlideOffset) {\n      this._slidesWithIndexes = this.mapSlidesAndIndexes();\n\n      if (this._slides.length - startIndex < this.itemsPerSlide) {\n        const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n\n        this._slidesWithIndexes  = [\n          ...this._slidesWithIndexes,\n          ...slidesToAppend\n        ]\n          .slice(slidesToAppend.length)\n          .slice(0, this.itemsPerSlide);\n      } else {\n        this._slidesWithIndexes = this._slidesWithIndexes.slice(\n          startIndex,\n          startIndex + this.itemsPerSlide\n        );\n      }\n\n      this._slidesWithIndexes.forEach((slide: SlideWithIndex) => slide.item.active = true);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n    } else {\n      this.selectRangeByNestedIndex(startIndex);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n\n  /**\n   * Defines next slide index, depending of direction\n   * @param direction: Direction(UNKNOWN|PREV|NEXT)\n   * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n   *   return undefined if next slide require wrapping\n   */\n  private findNextSlideIndex(direction: Direction, force: boolean): number {\n    let nextSlideIndex = 0;\n\n    if (\n      !force &&\n      (this.isLast(this.activeSlide) &&\n        direction !== Direction.PREV &&\n        this.noWrap)\n    ) {\n      return undefined;\n    }\n\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled\n        // and need to going forward - select current slide, as a next\n        nextSlideIndex = !this.isLast(this._currentActiveSlide)\n          ? this._currentActiveSlide + 1\n          : !force && this.noWrap ? this._currentActiveSlide : 0;\n        break;\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled\n        // and need to going backward - select current slide, as a next\n        nextSlideIndex =\n          this._currentActiveSlide > 0\n            ? this._currentActiveSlide - 1\n            : !force && this.noWrap\n              ? this._currentActiveSlide\n              : this._slides.length - 1;\n        break;\n      default:\n        throw new Error('Unknown direction');\n    }\n\n    return nextSlideIndex;\n  }\n\n  private mapSlidesAndIndexes(): SlideWithIndex[] {\n    return this.slides\n      .slice()\n      .map((slide: SlideComponent, index: number) => {\n        return {\n          index,\n          item: slide\n        };\n      });\n  }\n\n\n  private selectSlideRange(index: number): void {\n    if (this.isIndexInRange(index)) {\n      return;\n    }\n\n    this.hideSlides();\n\n    if (!this.singleSlideOffset) {\n      this.selectRangeByNestedIndex(index);\n    } else {\n      const startIndex = this.isIndexOnTheEdges(index)\n        ? index\n        : index - this.itemsPerSlide + 1;\n\n      const endIndex = this.isIndexOnTheEdges(index)\n        ? index + this.itemsPerSlide\n        : index + 1;\n\n      this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n\n      this._slidesWithIndexes.forEach((slide: SlideWithIndex) => slide.item.active = true);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n\n  private selectRangeByNestedIndex(index: number): void {\n    const selectedRange = this._chunkedSlides\n      .map((slidesList, i: number) => {\n        return {\n          index: i,\n          list: slidesList\n        };\n      })\n      .find(\n        (slidesList: IndexedSlideList) => {\n          return slidesList.list.find(slide => slide.index === index) !== undefined;\n        }\n      );\n\n    this._currentVisibleSlidesIndex = selectedRange.index;\n\n    this._chunkedSlides[selectedRange.index].forEach((slide: SlideWithIndex) => {\n      slide.item.active = true;\n    });\n  }\n\n  private isIndexOnTheEdges(index: number): boolean {\n    return (\n      index + 1 - this.itemsPerSlide <= 0 ||\n      index + this.itemsPerSlide <= this._slides.length\n    );\n  }\n\n  private isIndexInRange(index: number): boolean {\n    if (this.singleSlideOffset) {\n      const visibleIndexes = this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index);\n\n      return visibleIndexes.indexOf(index) >= 0;\n    }\n\n    return (\n      index <= this.getLastVisibleIndex() &&\n      index >= this.getFirstVisibleIndex()\n    );\n  }\n\n  private hideSlides(): void {\n    this.slides.forEach((slide: SlideComponent) => slide.active = false);\n  }\n\n  private isVisibleSlideListLast(): boolean {\n    return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n  }\n\n  private isVisibleSlideListFirst(): boolean {\n    return this._currentVisibleSlidesIndex === 0;\n  }\n\n  private moveSliderByOneItem(direction: Direction): void {\n    let firstVisibleIndex: number;\n    let lastVisibleIndex: number;\n    let indexToHide: number;\n    let indexToShow: number;\n\n    if (this.noWrap) {\n      firstVisibleIndex = this.getFirstVisibleIndex();\n      lastVisibleIndex = this.getLastVisibleIndex();\n\n      indexToHide = direction === Direction.NEXT\n        ? firstVisibleIndex\n        : lastVisibleIndex;\n\n      indexToShow = direction !== Direction.NEXT\n        ? firstVisibleIndex - 1\n        : !this.isLast(lastVisibleIndex)\n          ? lastVisibleIndex + 1 : 0;\n\n      this._slides.get(indexToHide).active = false;\n      this._slides.get(indexToShow).active = true;\n\n      const slidesToReorder = this.mapSlidesAndIndexes().filter(\n        (slide: SlideWithIndex) => slide.item.active\n      );\n\n      this.makeSlidesConsistent(slidesToReorder);\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    } else {\n      let displayedIndex: number;\n\n      firstVisibleIndex = this._slidesWithIndexes[0].index;\n      lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n\n      if (direction === Direction.NEXT) {\n        this._slidesWithIndexes.shift();\n\n        displayedIndex = this.isLast(lastVisibleIndex)\n          ? 0\n          : lastVisibleIndex + 1;\n\n        this._slidesWithIndexes.push({\n          index: displayedIndex,\n          item: this._slides.get(displayedIndex)\n        });\n      } else {\n        this._slidesWithIndexes.pop();\n        displayedIndex = this.isFirst(firstVisibleIndex)\n          ? this._slides.length - 1\n          : firstVisibleIndex - 1;\n\n        this._slidesWithIndexes = [{\n          index: displayedIndex,\n          item: this._slides.get(displayedIndex)\n        }, ...this._slidesWithIndexes];\n      }\n\n      this.hideSlides();\n\n      this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n\n      this.slideRangeChange.emit(\n        this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index)\n      );\n    }\n  }\n\n  private makeSlidesConsistent = (slides: SlideWithIndex[]): void => {\n    slides.forEach((slide: SlideWithIndex, index: number) => slide.item.order = index);\n  }\n\n  private moveMultilist(direction: Direction): void {\n    if (this.singleSlideOffset) {\n      this.moveSliderByOneItem(direction);\n    } else {\n      this.hideSlides();\n\n      if (this.noWrap) {\n        this._currentVisibleSlidesIndex = direction === Direction.NEXT\n          ? this._currentVisibleSlidesIndex + 1\n          : this._currentVisibleSlidesIndex - 1;\n      } else {\n        if (direction === Direction.NEXT) {\n          this._currentVisibleSlidesIndex = this.isVisibleSlideListLast()\n            ? 0\n            : this._currentVisibleSlidesIndex + 1;\n        } else {\n          this._currentVisibleSlidesIndex = this.isVisibleSlideListFirst()\n            ? this._chunkedSlides.length - 1\n            : this._currentVisibleSlidesIndex - 1;\n        }\n      }\n\n      this._chunkedSlides[this._currentVisibleSlidesIndex].forEach(\n        (slide: SlideWithIndex) => slide.item.active = true\n      );\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n  }\n\n  private getVisibleIndexes(): number[] {\n    if (!this.singleSlideOffset) {\n      return this._chunkedSlides[this._currentVisibleSlidesIndex]\n        .map((slide: SlideWithIndex) => slide.index);\n    } else {\n      return this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index);\n    }\n  }\n\n  /**\n   * Sets a slide, which specified through index, as active\n   * @param index\n   */\n  private _select(index: number): void {\n    if (isNaN(index)) {\n      this.pause();\n\n      return;\n    }\n\n    if (!this.multilist) {\n      const currentSlide = this._slides.get(this._currentActiveSlide);\n      if (currentSlide) {\n        currentSlide.active = false;\n      }\n    }\n\n    const nextSlide = this._slides.get(index);\n    if (nextSlide) {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  }\n\n  /**\n   * Starts loop of auto changing of slides\n   */\n  private restartTimer() {\n    this.resetTimer();\n    const interval = +this.interval;\n    if (!isNaN(interval) && interval > 0) {\n      this.currentInterval = this.ngZone.runOutsideAngular(() => {\n        return setInterval(() => {\n          const nInterval = +this.interval;\n          this.ngZone.run(() => {\n            if (\n              this.isPlaying &&\n              !isNaN(this.interval) &&\n              nInterval > 0 &&\n              this.slides.length\n            ) {\n              this.nextSlideFromInterval();\n            } else {\n              this.pause();\n            }\n          });\n        }, interval);\n      });\n    }\n  }\n\n  get multilist(): boolean {\n    return this.itemsPerSlide > 1;\n  }\n\n  /**\n   * Stops loop of auto changing of slides\n   */\n  private resetTimer(): void {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  }\n}\n","import {\r\n  Component,\r\n  HostBinding,\r\n  OnDestroy,\r\n  Input,\r\n  OnInit\r\n} from '@angular/core';\r\n\r\nimport { CarouselComponent } from './carousel.component';\r\n\r\n@Component({\r\n  selector: 'slide',\r\n  template: `\r\n    <div [class.active]=\"active\" class=\"item\">\r\n      <ng-content></ng-content>\r\n    </div>\r\n  `,\r\n  host: {\r\n    '[attr.aria-hidden]': '!active'\r\n  },\r\n  styles: [`\r\n    :host.carousel-animation {\r\n       transition: opacity 0.6s ease, visibility 0.6s ease;\r\n       float: left;\r\n    }\r\n    :host.carousel-animation.active {\r\n      opacity: 1;\r\n      visibility: visible;\r\n    }\r\n    :host.carousel-animation:not(.active) {\r\n      display: block;\r\n      position: absolute;\r\n      opacity: 0;\r\n      visibility: hidden;\r\n    }\r\n  `]\r\n})\r\nexport class SlideComponent implements OnInit, OnDestroy {\r\n  /** Is current slide active */\r\n  @HostBinding('class.active')\r\n  @Input()\r\n  active: boolean;\r\n\r\n  @HostBinding('style.width') itemWidth = '100%';\r\n  @HostBinding('style.order') order = 0;\r\n  @HostBinding('class.carousel-animation') isAnimated: boolean;\r\n\r\n  /** Wraps element by appropriate CSS classes */\r\n  @HostBinding('class.item')\r\n  @HostBinding('class.carousel-item')\r\n  addClass = true;\r\n\r\n  /** Link to Parent(container-collection) component */\r\n  protected carousel: CarouselComponent;\r\n\r\n  constructor(carousel: CarouselComponent) {\r\n    this.carousel = carousel;\r\n  }\r\n\r\n  /** Fires changes in container collection after adding a new slide instance */\r\n  ngOnInit(): void {\r\n    this.carousel.addSlide(this);\r\n    this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\r\n  }\r\n\r\n  /** Fires changes in container collection after removing of this slide instance */\r\n  ngOnDestroy(): void {\r\n    this.carousel.removeSlide(this);\r\n  }\r\n}\r\n","import { CommonModule } from '@angular/common';\r\nimport { NgModule, ModuleWithProviders } from '@angular/core';\r\n\r\nimport { CarouselComponent } from './carousel.component';\r\nimport { SlideComponent } from './slide.component';\r\n\r\n@NgModule({\r\n  imports: [CommonModule],\r\n  declarations: [SlideComponent, CarouselComponent],\r\n  exports: [SlideComponent, CarouselComponent]\r\n})\r\nexport class CarouselModule {\r\n  static forRoot(): ModuleWithProviders<CarouselModule> {\r\n    return { ngModule: CarouselModule, providers: [] };\r\n  }\r\n}\r\n"],"sourceRoot":"webpack:///"}